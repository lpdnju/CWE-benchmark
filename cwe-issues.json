[
  {
    "CWE-ID": "CWE-22",
    "Name": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')",
    "Category": "Path Traversal",
    "Severity": "High",
    "Description": "The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",
    "Applicable Platforms": {
      "languages": [
        {
          "class": "Not Language-Specific",
          "prevalence": "Undetermined"
        }
      ],
      "technologies": [
        {
          "name": "AI/ML",
          "prevalence": "Undetermined"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Implementation",
        "strategy": "Input Validation",
        "description": "Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When validating filenames, use stringent allowlists that limit the character set to be used. If feasible, only allow a single . character in the filename to avoid weaknesses such as CWE-23, and exclude directory separators such as / to avoid CWE-36. Use a list of allowable file extensions, which will help to avoid CWE-434. Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a denylist, which may be incomplete (CWE-184). For example, filtering / is insufficient protection if the filesystem also supports the use of as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE-182). For example, if ../ sequences are removed from the .../...// string in a sequential fashion, two instances of ../ would be removed from the original string, but the remaining characters would still form the ../ string."
      },
      {
        "phase": "Architecture and Design",
        "description": "For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server."
      },
      {
        "phase": "Implementation",
        "strategy": "Input Validation",
        "description": "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked. Use a built-in path canonicalization function (such as realpath() in C) that produces the canonical version of the pathname, which effectively removes .. sequences and symbolic links (CWE-23, CWE-59). This includes"
      },
      {
        "phase": "Architecture and Design",
        "strategy": "Libraries or Frameworks",
        "description": "Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid [REF-1482]."
      },
      {
        "phase": "Operation",
        "strategy": "Firewall",
        "description": "Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth [REF-1481].",
        "effectiveness": "Moderate"
      },
      {
        "phase": "Architecture and Design Operation",
        "strategy": "Environment Hardening",
        "description": "Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations."
      },
      {
        "phase": "Architecture and Design",
        "strategy": "Enforcement by Conversion",
        "description": "When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs. For example, ID 1 could map to inbox.txt and ID 2 could map to profile.txt. Features such as the ESAPI AccessReferenceMap [REF-185] provide this capability."
      },
      {
        "phase": "Architecture and Design Operation",
        "strategy": "Sandbox or Jail",
        "description": "Run the code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise. Be careful to avoid CWE-243 and other weaknesses related to jails.",
        "effectiveness": "Limited"
      },
      {
        "phase": "Architecture and Design Operation",
        "strategy": "Attack Surface Reduction",
        "description": "Store library, include, and utility files outside of the web document root, if possible. Otherwise, store them in a separate directory and use the web server's access control capabilities to prevent attackers from directly requesting them. One common practice is to define a fixed constant in each calling program, then check for the existence of the constant in the library/include file; if the constant does not exist, then the file was directly requested, and it can exit immediately. This significantly reduces the chance of an attacker being able to bypass any protection mechanisms that are in the base program but not in the include files. It will also reduce the attack surface."
      },
      {
        "phase": "Implementation",
        "description": "Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success. If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files. Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not. In the context of path traversal, error messages which disclose path information can help attackers craft the appropriate attack strings to move through the file system hierarchy."
      },
      {
        "phase": "Operation Implementation",
        "strategy": "Environment Hardening",
        "description": "When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues."
      }
    ]
  },
  {
    "CWE-ID": "CWE-23",
    "Name": "Relative Path Traversal",
    "Category": "Path Traversal",
    "Severity": "High",
    "Description": "The product uses external input to construct a pathname that should be within a restricted directory, but it does not properly neutralize sequences such as .. that can resolve to a location that is outside of that directory.",
    "Applicable Platforms": {
      "languages": [
        {
          "class": "Not Language-Specific",
          "prevalence": "Undetermined"
        }
      ],
      "technologies": [
        {
          "name": "AI/ML",
          "prevalence": "Undetermined"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Implementation",
        "strategy": "Input Validation",
        "description": "Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When validating filenames, use stringent allowlists that limit the character set to be used. If feasible, only allow a single . character in the filename to avoid weaknesses such as CWE-23, and exclude directory separators such as / to avoid CWE-36. Use a list of allowable file extensions, which will help to avoid CWE-434. Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a denylist, which may be incomplete (CWE-184). For example, filtering / is insufficient protection if the filesystem also supports the use of as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE-182). For example, if ../ sequences are removed from the .../...// string in a sequential fashion, two instances of ../ would be removed from the original string, but the remaining characters would still form the ../ string."
      },
      {
        "phase": "Implementation",
        "strategy": "Input Validation",
        "description": "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked. Use a built-in path canonicalization function (such as realpath() in C) that produces the canonical version of the pathname, which effectively removes .. sequences and symbolic links (CWE-23, CWE-59). This includes"
      },
      {
        "phase": "Operation",
        "strategy": "Firewall",
        "description": "Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth [REF-1481].",
        "effectiveness": "Moderate"
      }
    ]
  },
  {
    "CWE-ID": "CWE-36",
    "Name": "Absolute Path Traversal",
    "Category": "Path Traversal",
    "Severity": "High",
    "Description": "The product uses external input to construct a pathname that should be within a restricted directory, but it does not properly neutralize absolute path sequences such as /abs/path that can resolve to a location that is outside of that directory.",
    "Applicable Platforms": {
      "languages": [
        {
          "class": "Not Language-Specific",
          "prevalence": "Undetermined"
        }
      ],
      "technologies": [
        {
          "name": "AI/ML",
          "prevalence": "Undetermined"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Implementation",
        "strategy": "Input Validation",
        "description": "Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When validating filenames, use stringent allowlists that limit the character set to be used. If feasible, only allow a single . character in the filename to avoid weaknesses such as CWE-23, and exclude directory separators such as / to avoid CWE-36. Use a list of allowable file extensions, which will help to avoid CWE-434. Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a denylist, which may be incomplete (CWE-184). For example, filtering / is insufficient protection if the filesystem also supports the use of as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE-182). For example, if ../ sequences are removed from the .../...// string in a sequential fashion, two instances of ../ would be removed from the original string, but the remaining characters would still form the ../ string.",
        "effectiveness": "High"
      },
      {
        "phase": "Implementation",
        "strategy": "Input Validation",
        "description": "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass allowlist validation schemes by introducing dangerous inputs after they have been checked."
      },
      {
        "phase": "Operation",
        "strategy": "Firewall",
        "description": "Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth [REF-1481].",
        "effectiveness": "Moderate"
      }
    ]
  },
  {
    "CWE-ID": "CWE-77",
    "Name": "Improper Neutralization of Special Elements used in a Command ('Command Injection')",
    "Category": "Command Injection",
    "Severity": "Critical",
    "Description": "The product constructs all or part of a command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended command when it is sent to a downstream component.",
    "Applicable Platforms": {
      "languages": [
        {
          "class": "Not Language-Specific",
          "prevalence": "Undetermined"
        }
      ],
      "technologies": [
        {
          "name": "AI/ML",
          "prevalence": "Undetermined"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Architecture and Design",
        "description": "If at all possible, use library calls rather than external processes to recreate the desired functionality."
      },
      {
        "phase": "Implementation",
        "description": "If possible, ensure that all external commands called from the program are statically created."
      },
      {
        "phase": "Implementation",
        "strategy": "Input Validation",
        "description": "Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright."
      },
      {
        "phase": "Operation",
        "description": "Run time"
      },
      {
        "phase": "System Configuration",
        "description": "Assign permissions that prevent the user from accessing/opening privileged files."
      }
    ]
  },
  {
    "CWE-ID": "CWE-78",
    "Name": "Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')",
    "Category": "Command Injection",
    "Severity": "Critical",
    "Description": "The product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.",
    "Applicable Platforms": {
      "languages": [
        {
          "class": "Not Language-Specific",
          "prevalence": "Undetermined"
        }
      ],
      "technologies": [
        {
          "name": "AI/ML",
          "prevalence": "Undetermined"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Architecture and Design",
        "description": "If at all possible, use library calls rather than external processes to recreate the desired functionality."
      },
      {
        "phase": "Architecture and Design Operation",
        "strategy": "Sandbox or Jail",
        "description": "Run the code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise. Be careful to avoid CWE-243 and other weaknesses related to jails.",
        "effectiveness": "Limited"
      },
      {
        "phase": "Architecture and Design",
        "strategy": "Attack Surface Reduction",
        "description": "For any data that will be used to generate a command to be executed, keep as much of that data out of external control as possible. For example, in web applications, this may require storing the data locally in the session's state instead of sending it out to the client in a hidden form field."
      },
      {
        "phase": "Architecture and Design",
        "description": "For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server."
      },
      {
        "phase": "Architecture and Design",
        "strategy": "Libraries or Frameworks",
        "description": "Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, consider using the ESAPI Encoding control [REF-45] or a similar tool, library, or framework. These will help the programmer encode outputs in a manner less prone to error."
      },
      {
        "phase": "Implementation",
        "strategy": "Output Encoding",
        "description": "While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88)."
      },
      {
        "phase": "Implementation",
        "description": "If the program to be executed allows arguments to be specified within an input file or from standard input, then consider using that mode to pass arguments instead of the command line."
      },
      {
        "phase": "Architecture and Design",
        "strategy": "Parameterization",
        "description": "If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated. Some languages offer multiple functions that can be used to invoke commands. Where possible, identify any function that invokes a command shell using a single string, and replace it with a function that requires individual arguments. These functions typically perform appropriate quoting and filtering of arguments. For example, in C, the system() function accepts a string that contains the entire command to be executed, whereas execl(), execve(), and others require an array of strings, one for each argument. In Windows, CreateProcess() only accepts one command at a time. In Perl, if system() is provided with an array of arguments, then it will quote each of the arguments."
      },
      {
        "phase": "Implementation",
        "strategy": "Input Validation",
        "description": "Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When constructing OS command strings, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. This will indirectly limit the scope of an attack, but this technique is less important than proper output encoding and escaping. Note that proper output encoding, escaping, and quoting is the most effective solution for preventing OS command injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent OS command injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, when invoking a mail program, you might need to allow the subject field to contain otherwise-dangerous inputs like ; and > characters, which would need to be escaped or otherwise handled. In this case, stripping the character might reduce the risk of OS command injection, but it would produce incorrect behavior because the subject field would not be recorded as the user intended. This might seem to be a minor inconvenience, but it could be more important when the program relies on well-structured subject lines in order to pass messages to other components. Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address."
      },
      {
        "phase": "Architecture and Design",
        "strategy": "Enforcement by Conversion",
        "description": "When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs."
      },
      {
        "phase": "Operation",
        "strategy": "Compilation or Build Hardening",
        "description": "Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's -T switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184)."
      },
      {
        "phase": "Operation",
        "strategy": "Environment Hardening",
        "description": "Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's -T switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184)."
      },
      {
        "phase": "Implementation",
        "description": "Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success. If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files. Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not. In the context of OS Command Injection, error information passed back to the user might reveal whether an OS command is being executed and possibly which command is being used."
      },
      {
        "phase": "Operation",
        "strategy": "Sandbox or Jail",
        "description": "Use runtime policy enforcement to create an allowlist of allowable commands, then prevent use of any command that does not appear in the allowlist. Technologies such as AppArmor are available to do this."
      },
      {
        "phase": "Operation",
        "strategy": "Firewall",
        "description": "Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth [REF-1481].",
        "effectiveness": "Moderate"
      },
      {
        "phase": "Architecture and Design Operation",
        "strategy": "Environment Hardening",
        "description": "Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations."
      },
      {
        "phase": "Operation Implementation",
        "strategy": "Environment Hardening",
        "description": "When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues."
      }
    ]
  },
  {
    "CWE-ID": "CWE-79",
    "Name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')",
    "Category": "Cross-Site Scripting",
    "Severity": "High",
    "Description": "The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.",
    "Applicable Platforms": {
      "languages": [
        {
          "class": "Not Language-Specific",
          "prevalence": "Undetermined"
        }
      ],
      "technologies": [
        {
          "name": "AI/ML",
          "prevalence": "Undetermined"
        },
        {
          "class": "Web Based",
          "prevalence": "Often"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Architecture and Design",
        "strategy": "Libraries or Frameworks",
        "description": "Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid [REF-1482]. Examples of libraries and frameworks that make it easier to generate properly encoded output include Microsoft's Anti-XSS library, the OWASP ESAPI Encoding module, and Apache Wicket."
      },
      {
        "phase": "Implementation Architecture and Design",
        "description": "Understand the context in which your data will be used and the encoding that will be expected. This is especially important when transmitting data between different components, or when generating outputs that can contain multiple encodings at the same time, such as web pages or multi-part mail messages. Study all expected communication protocols and data representations to determine the required encoding strategies. For any data that will be output to another web page, especially any data that was received from external inputs, use the appropriate encoding on all non-alphanumeric characters. Parts of the same output document may require different encodings, which will vary depending on whether the output is in the"
      },
      {
        "phase": "Architecture and Design Implementation",
        "strategy": "Attack Surface Reduction",
        "description": "Understand all the potential areas where untrusted inputs can enter your software"
      },
      {
        "phase": "Architecture and Design",
        "description": "For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server."
      },
      {
        "phase": "Architecture and Design",
        "strategy": "Parameterization",
        "description": "If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated."
      },
      {
        "phase": "Implementation",
        "strategy": "Output Encoding",
        "description": "Use and specify an output encoding that can be handled by the downstream component that is reading the output. Common encodings include ISO-8859-1, UTF-7, and UTF-8. When an encoding is not specified, a downstream component may choose a different encoding, either by assuming a default encoding or automatically inferring which encoding is being used, which can be erroneous. When the encodings are inconsistent, the downstream component might treat some character or byte sequences as special, even if they are not special in the original encoding. Attackers might then be able to exploit this discrepancy and conduct injection attacks; they even might be able to bypass protection mechanisms that assume the original encoding is also being used by the downstream component. The problem of inconsistent output encodings often arises in web pages. If an encoding is not specified in an HTTP header, web browsers often guess about which encoding is being used. This can open up the browser to subtle XSS attacks."
      },
      {
        "phase": "Implementation",
        "description": "With Struts, write all data from form beans with the bean's filter attribute set to true."
      },
      {
        "phase": "Implementation",
        "strategy": "Attack Surface Reduction",
        "description": "To help mitigate XSS attacks against the user's session cookie, set the session cookie to be HttpOnly. In browsers that support the HttpOnly feature (such as more recent versions of Internet Explorer and Firefox), this attribute can prevent the user's session cookie from being accessible to malicious client-side scripts that use document.cookie. This is not a complete solution, since HttpOnly is not supported by all browsers. More importantly, XMLHTTPRequest and other powerful browser technologies provide read access to HTTP headers, including the Set-Cookie header in which the HttpOnly flag is set.",
        "effectiveness": "Defense in Depth"
      },
      {
        "phase": "Implementation",
        "strategy": "Input Validation",
        "description": "Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When dynamically constructing web pages, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. All input should be validated and cleansed, not just parameters that the user is supposed to specify, but all data in the request, including hidden fields, cookies, headers, the URL itself, and so forth. A common mistake that leads to continuing XSS vulnerabilities is to validate only fields that are expected to be redisplayed by the site. It is common to see data from the request that is reflected by the application server or the application that the development team did not anticipate. Also, a field that is not currently reflected may be used by a future developer. Therefore, validating ALL parts of the HTTP request is recommended. Note that proper output encoding, escaping, and quoting is the most effective solution for preventing XSS, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent XSS, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, in a chat application, the heart emoticon (<3) would likely pass the validation step, since it is commonly used. However, it cannot be directly inserted into the web page because it contains the < character, which would need to be escaped or otherwise handled. In this case, stripping the < might reduce the risk of XSS, but it would produce incorrect behavior because the emoticon would not be recorded. This might seem to be a minor inconvenience, but it would be more important in a mathematical forum that wants to represent inequalities. Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address. Ensure that you perform input validation at well-defined interfaces within the application. This will help protect the application even if a component is reused or moved elsewhere."
      },
      {
        "phase": "Architecture and Design",
        "strategy": "Enforcement by Conversion",
        "description": "When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs."
      },
      {
        "phase": "Operation",
        "strategy": "Firewall",
        "description": "Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth [REF-1481].",
        "effectiveness": "Moderate"
      },
      {
        "phase": "Operation Implementation",
        "strategy": "Environment Hardening",
        "description": "When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues."
      }
    ]
  },
  {
    "CWE-ID": "CWE-88",
    "Name": "Improper Neutralization of Argument Delimiters in a Command ('Argument Injection')",
    "Category": "Command Injection",
    "Severity": "High",
    "Description": "The product constructs a string for a command to be executed by a separate component in another control sphere, but it does not properly delimit the intended arguments, options, or switches within that command string.",
    "Applicable Platforms": {
      "languages": [
        {
          "class": "Not Language-Specific",
          "prevalence": "Undetermined"
        },
        {
          "name": "PHP",
          "prevalence": "Often"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Implementation",
        "strategy": "Parameterization",
        "description": "Where possible, avoid building a single string that contains the command and its arguments. Some languages or frameworks have functions that support specifying independent arguments, e.g. as an array, which is used to automatically perform the appropriate quoting or escaping while building the command. For example, in PHP, escapeshellarg() can be used to escape a single argument to system(), or exec() can be called with an array of arguments. In C, code can often be refactored from using system() - which accepts a single string - to using exec(), which requires separate function arguments for each parameter.",
        "effectiveness": "High"
      },
      {
        "phase": "Architecture and Design",
        "strategy": "Input Validation",
        "description": "Understand all the potential areas where untrusted inputs can enter your product"
      },
      {
        "phase": "Implementation",
        "strategy": "Input Validation",
        "description": "Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright."
      },
      {
        "phase": "Implementation",
        "description": "Directly convert your input type into the expected data type, such as using a conversion function that translates a string into a number. After converting to the expected data type, ensure that the input's values fall within the expected range of allowable values and that multi-field consistencies are maintained."
      },
      {
        "phase": "Implementation",
        "description": "Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180, CWE-181). Make sure that your application does not inadvertently decode the same input twice (CWE-174). Such errors could be used to bypass allowlist schemes by introducing dangerous inputs after they have been checked. Use libraries such as the OWASP ESAPI Canonicalization control. Consider performing repeated canonicalization until your input does not change any more. This will avoid double-decoding and similar scenarios, but it might inadvertently modify inputs that are allowed to contain properly-encoded dangerous content."
      },
      {
        "phase": "Implementation",
        "description": "When exchanging data between components, ensure that both components are using the same character encoding. Ensure that the proper encoding is applied at each interface. Explicitly set the encoding you are using whenever the protocol allows you to do so."
      },
      {
        "phase": "Implementation",
        "description": "When your application combines data from multiple sources, perform the validation after the sources have been combined. The individual data elements may pass the validation step but violate the intended restrictions after they have been combined."
      },
      {
        "phase": "Testing",
        "description": "Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible."
      },
      {
        "phase": "Testing",
        "description": "Use dynamic tools and techniques that interact with the product using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The product's operation may slow down, but it should not become unstable, crash, or generate incorrect results."
      }
    ]
  },
  {
    "CWE-ID": "CWE-89",
    "Name": "Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')",
    "Category": "SQL Injection",
    "Severity": "Critical",
    "Description": "The product constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component. Without sufficient removal or quoting of SQL syntax in user-controllable inputs, the generated SQL query can cause those inputs to be interpreted as SQL instead of ordinary user data.",
    "Applicable Platforms": {
      "languages": [
        {
          "class": "Not Language-Specific",
          "prevalence": "Undetermined"
        },
        {
          "name": "SQL",
          "prevalence": "Often"
        }
      ],
      "technologies": [
        {
          "name": "Database Server",
          "prevalence": "Undetermined"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Architecture and Design",
        "strategy": "Libraries or Frameworks",
        "description": "Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid [REF-1482]. For example, consider using persistence layers such as Hibernate or Enterprise Java Beans, which can provide significant protection against SQL injection if used properly."
      },
      {
        "phase": "Architecture and Design",
        "strategy": "Parameterization",
        "description": "If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated. Process SQL queries using prepared statements, parameterized queries, or stored procedures. These features should accept parameters or variables and support strong typing. Do not dynamically construct and execute query strings within these features using exec or similar functionality, since this may re-introduce the possibility of SQL injection. [REF-867]"
      },
      {
        "phase": "Architecture and Design Operation",
        "strategy": "Environment Hardening",
        "description": "Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations. Specifically, follow the principle of least privilege when creating user accounts to a SQL database. The database users should only have the minimum privileges necessary to use their account. If the requirements of the system indicate that a user can read and modify their own data, then limit their privileges so they cannot read/write others' data. Use the strictest permissions possible on all database objects, such as execute-only for stored procedures."
      },
      {
        "phase": "Architecture and Design",
        "description": "For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server."
      },
      {
        "phase": "Implementation",
        "strategy": "Output Encoding",
        "description": "While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict allowlist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88). Instead of building a new implementation, such features may be available in the database or programming language. For example, the Oracle DBMS_ASSERT package can check or enforce that parameters have certain properties that make them less vulnerable to SQL injection. For MySQL, the mysql_real_escape_string() API function is available in both C and PHP."
      },
      {
        "phase": "Implementation",
        "strategy": "Input Validation",
        "description": "Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When constructing SQL query strings, use stringent allowlists that limit the character set based on the expected value of the parameter in the request. This will indirectly limit the scope of an attack, but this technique is less important than proper output encoding and escaping. Note that proper output encoding, escaping, and quoting is the most effective solution for preventing SQL injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent SQL injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, the name O'Reilly would likely pass the validation step, since it is a common last name in the English language. However, it cannot be directly inserted into the database because it contains the ' apostrophe character, which would need to be escaped or otherwise handled. In this case, stripping the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded. When feasible, it may be safest to disallow meta-characters entirely, instead of escaping them. This will provide some defense in depth. After the data is entered into the database, later processes may neglect to escape meta-characters before use, and you may not have control over those processes."
      },
      {
        "phase": "Architecture and Design",
        "strategy": "Enforcement by Conversion",
        "description": "When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs."
      },
      {
        "phase": "Implementation",
        "description": "Ensure that error messages only contain minimal details that are useful to the intended audience and no one else. The messages need to strike the balance between being too cryptic (which can confuse users) or being too detailed (which may reveal more than intended). The messages should not reveal the methods that were used to determine the error. Attackers can use detailed information to refine or optimize their original attack, thereby increasing their chances of success. If errors must be captured in some detail, record them in log messages, but consider what could occur if the log messages can be viewed by attackers. Highly sensitive information such as passwords should never be saved to log files. Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a user account exists or not. In the context of SQL Injection, error messages revealing the structure of a SQL query can help attackers tailor successful attack strings."
      },
      {
        "phase": "Operation",
        "strategy": "Firewall",
        "description": "Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth [REF-1481.",
        "effectiveness": "Moderate"
      },
      {
        "phase": "Operation Implementation",
        "strategy": "Environment Hardening",
        "description": "When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues."
      }
    ]
  },
  {
    "CWE-ID": "CWE-90",
    "Name": "Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')",
    "Category": "LDAP Injection",
    "Severity": "High",
    "Description": "The product constructs all or part of an LDAP query using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended LDAP query when it is sent to a downstream component.",
    "Applicable Platforms": {
      "languages": [
        {
          "class": "Not Language-Specific",
          "prevalence": "Undetermined"
        }
      ],
      "technologies": [
        {
          "name": "Database Server",
          "prevalence": "Undetermined"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Implementation",
        "strategy": "Input Validation",
        "description": "Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright."
      }
    ]
  },
  {
    "CWE-ID": "CWE-91",
    "Name": "XML Injection (aka Blind XPath Injection)",
    "Category": "XML Injection",
    "Severity": "High",
    "Description": "The product does not properly neutralize special elements that are used in XML, allowing attackers to modify the syntax, content, or commands of the XML before it is processed by an end system.",
    "Applicable Platforms": {
      "languages": [
        {
          "class": "Not Language-Specific",
          "prevalence": "Undetermined"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Implementation",
        "strategy": "Input Validation",
        "description": "Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright."
      }
    ]
  },
  {
    "CWE-ID": "CWE-99",
    "Name": "Improper Control of Resource Identifiers ('Resource Injection')",
    "Category": "Resource Injection",
    "Severity": "Medium",
    "Description": "The product receives input from an upstream component, but it does not restrict or incorrectly restricts the input before it is used as an identifier for a resource that may be outside the intended sphere of control.",
    "Applicable Platforms": {
      "languages": [
        {
          "class": "Not Language-Specific",
          "prevalence": "Undetermined"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Implementation",
        "strategy": "Input Validation",
        "description": "Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, it can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright."
      }
    ]
  },
  {
    "CWE-ID": "CWE-119",
    "Name": "Improper Restriction of Operations within the Bounds of a Memory Buffer",
    "Category": "Memory Buffer Error",
    "Severity": "Critical",
    "Description": "The product performs operations on a memory buffer, but it reads from or writes to a memory location outside the buffer's intended boundary. This may result in read or write operations on unexpected memory locations that could be linked to other variables, data structures, or internal program data.",
    "Applicable Platforms": {
      "languages": [
        {
          "name": "C",
          "prevalence": "Often"
        },
        {
          "name": "C++",
          "prevalence": "Often"
        },
        {
          "class": "Assembly",
          "prevalence": "Undetermined"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Requirements",
        "strategy": "Language Selection",
        "description": "Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer. Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe."
      },
      {
        "phase": "Architecture and Design",
        "strategy": "Libraries or Frameworks",
        "description": "Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions."
      },
      {
        "phase": "Operation Build and Compilation",
        "strategy": "Environment Hardening",
        "description": "Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include"
      },
      {
        "phase": "Implementation",
        "description": "Consider adhering to the following rules when allocating and managing an application's memory"
      },
      {
        "phase": "Operation Build and Compilation",
        "strategy": "Environment Hardening",
        "description": "Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as rebasing (for Windows) and prelinking (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking. For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].",
        "effectiveness": "Defense in Depth"
      },
      {
        "phase": "Operation",
        "strategy": "Environment Hardening",
        "description": "Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment. For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].",
        "effectiveness": "Defense in Depth"
      },
      {
        "phase": "Implementation",
        "description": "Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.",
        "effectiveness": "Moderate"
      }
    ]
  },
  {
    "CWE-ID": "CWE-120",
    "Name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",
    "Category": "Memory Buffer Error",
    "Severity": "Critical",
    "Description": "The product copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer.",
    "Applicable Platforms": {
      "languages": [
        {
          "name": "C",
          "prevalence": "Often"
        },
        {
          "name": "C++",
          "prevalence": "Often"
        },
        {
          "class": "Assembly",
          "prevalence": "Undetermined"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Requirements",
        "strategy": "Language Selection",
        "description": "Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer. Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe."
      },
      {
        "phase": "Architecture and Design",
        "strategy": "Libraries or Frameworks",
        "description": "Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions."
      },
      {
        "phase": "Operation Build and Compilation",
        "strategy": "Environment Hardening",
        "description": "Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include"
      },
      {
        "phase": "Implementation",
        "description": "Consider adhering to the following rules when allocating and managing an application's memory"
      },
      {
        "phase": "Implementation",
        "strategy": "Input Validation",
        "description": "Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright."
      },
      {
        "phase": "Architecture and Design",
        "description": "For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server."
      },
      {
        "phase": "Operation Build and Compilation",
        "strategy": "Environment Hardening",
        "description": "Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as rebasing (for Windows) and prelinking (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking. For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].",
        "effectiveness": "Defense in Depth"
      },
      {
        "phase": "Operation",
        "strategy": "Environment Hardening",
        "description": "Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment. For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].",
        "effectiveness": "Defense in Depth"
      },
      {
        "phase": "Build and Compilation Operation",
        "description": "Most mitigating technologies at the compiler or OS level to date address only a subset of buffer overflow problems and rarely provide complete protection against even that subset. It is good practice to implement strategies to increase the workload of an attacker, such as leaving the attacker to guess an unknown value that changes every program execution."
      },
      {
        "phase": "Implementation",
        "description": "Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.",
        "effectiveness": "Moderate"
      },
      {
        "phase": "Architecture and Design",
        "strategy": "Enforcement by Conversion",
        "description": "When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs."
      },
      {
        "phase": "Architecture and Design Operation",
        "strategy": "Environment Hardening",
        "description": "Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations."
      },
      {
        "phase": "Architecture and Design Operation",
        "strategy": "Sandbox or Jail",
        "description": "Run the code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise. Be careful to avoid CWE-243 and other weaknesses related to jails.",
        "effectiveness": "Limited"
      }
    ]
  },
  {
    "CWE-ID": "CWE-123",
    "Name": "Write-what-where Condition",
    "Category": "Memory Buffer Error",
    "Severity": "Critical",
    "Description": "Any condition where the attacker has the ability to write an arbitrary value to an arbitrary location, often as the result of a buffer overflow.",
    "Applicable Platforms": {
      "languages": [
        {
          "name": "C",
          "prevalence": "Undetermined"
        },
        {
          "name": "C++",
          "prevalence": "Undetermined"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Architecture and Design",
        "strategy": "Language Selection",
        "description": "Use a language that provides appropriate memory abstractions."
      },
      {
        "phase": "Operation",
        "description": "Use OS-level preventative functionality integrated after the fact. Not a complete solution."
      }
    ]
  },
  {
    "CWE-ID": "CWE-125",
    "Name": "Out-of-bounds Read",
    "Category": "Memory Buffer Error",
    "Severity": "High",
    "Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
    "Applicable Platforms": {
      "languages": [
        {
          "name": "C",
          "prevalence": "Undetermined"
        },
        {
          "name": "C++",
          "prevalence": "Undetermined"
        }
      ],
      "technologies": [
        {
          "class": "ICS/OT",
          "prevalence": "Often"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Implementation",
        "strategy": "Input Validation",
        "description": "Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. To reduce the likelihood of introducing an out-of-bounds read, ensure that you validate and ensure correct calculations for any length argument, buffer size calculation, or offset. Be especially careful of relying on a sentinel (i.e. special character such as NUL) in untrusted inputs."
      },
      {
        "phase": "Architecture and Design",
        "strategy": "Language Selection",
        "description": "Use a language that provides appropriate memory abstractions."
      }
    ]
  },
  {
    "CWE-ID": "CWE-130",
    "Name": "Improper Handling of Length Parameter Inconsistency",
    "Category": "Data Handling Error",
    "Severity": "Medium",
    "Description": "The product parses a formatted message or structure, but it does not handle or incorrectly handles a length field that is inconsistent with the actual length of the associated data.",
    "Applicable Platforms": {
      "languages": [
        {
          "name": "C",
          "prevalence": "Sometimes"
        },
        {
          "name": "C++",
          "prevalence": "Sometimes"
        },
        {
          "class": "Not Language-Specific",
          "prevalence": "Undetermined"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Implementation",
        "description": "When processing structured incoming data containing a size field followed by raw data, ensure that you identify and resolve any inconsistencies between the size field and the actual size of the data."
      },
      {
        "phase": "Implementation",
        "description": "Do not let the user control the size of the buffer."
      },
      {
        "phase": "Implementation",
        "description": "Validate that the length of the user-supplied data is consistent with the buffer size."
      }
    ]
  },
  {
    "CWE-ID": "CWE-259",
    "Name": "Use of Hard-coded Password",
    "Category": "Hard-coded Credentials",
    "Severity": "High",
    "Description": "The product contains a hard-coded password, which it uses for its own inbound authentication or for outbound communication to external components.",
    "Applicable Platforms": {
      "languages": [
        {
          "class": "Not Language-Specific",
          "prevalence": "Undetermined"
        }
      ],
      "technologies": [
        {
          "class": "ICS/OT",
          "prevalence": "Undetermined"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Architecture and Design",
        "description": "For outbound authentication"
      },
      {
        "phase": "Architecture and Design",
        "description": "For inbound authentication"
      },
      {
        "phase": "Architecture and Design",
        "description": "Perform access control checks and limit which entities can access the feature that requires the hard-coded password. For example, a feature might only be enabled through the system console instead of through a network connection."
      },
      {
        "phase": "Architecture and Design",
        "description": "For inbound authentication"
      },
      {
        "phase": "Architecture and Design",
        "description": "For front-end to back-end connections"
      }
    ]
  },
  {
    "CWE-ID": "CWE-321",
    "Name": "Use of Hard-coded Cryptographic Key",
    "Category": "Hard-coded Credentials",
    "Severity": "Medium",
    "Description": "The product uses a hard-coded, unchangeable cryptographic key.",
    "Applicable Platforms": {
      "languages": [
        {
          "class": "Not Language-Specific",
          "prevalence": "Undetermined"
        }
      ],
      "technologies": [
        {
          "class": "ICS/OT",
          "prevalence": "Undetermined"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Architecture and Design",
        "description": "Prevention schemes mirror that of hard-coded password storage."
      }
    ]
  },
  {
    "CWE-ID": "CWE-415",
    "Name": "Double Free",
    "Category": "Memory Management Error",
    "Severity": "High",
    "Description": "The product calls free() twice on the same memory address.",
    "Applicable Platforms": {
      "languages": [
        {
          "name": "C",
          "prevalence": "Undetermined"
        },
        {
          "name": "C++",
          "prevalence": "Undetermined"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Architecture and Design",
        "description": "Choose a language that provides automatic memory management."
      },
      {
        "phase": "Implementation",
        "description": "Ensure that each allocation is freed only once. After freeing a chunk, set the pointer to NULL to ensure the pointer cannot be freed again. In complicated error conditions, be sure that clean-up routines respect the state of allocation properly. If the language is object oriented, ensure that object destructors delete each chunk of memory only once."
      },
      {
        "phase": "Implementation",
        "description": "Use a static analysis tool to find double free instances."
      }
    ]
  },
  {
    "CWE-ID": "CWE-416",
    "Name": "Use After Free",
    "Category": "Memory Management Error",
    "Severity": "Critical",
    "Description": "The product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory belongs to the code that operates on the new pointer.",
    "Applicable Platforms": {
      "languages": [
        {
          "name": "C",
          "prevalence": "Undetermined"
        },
        {
          "name": "C++",
          "prevalence": "Undetermined"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Architecture and Design",
        "strategy": "Language Selection",
        "description": "Choose a language that provides automatic memory management."
      },
      {
        "phase": "Implementation",
        "strategy": "Attack Surface Reduction",
        "description": "When freeing pointers, be sure to set them to NULL once they are freed. However, the utilization of multiple or complex data structures may lower the usefulness of this strategy.",
        "effectiveness": "Defense in Depth"
      }
    ]
  },
  {
    "CWE-ID": "CWE-434",
    "Name": "Unrestricted Upload of File with Dangerous Type",
    "Category": "File Upload Vulnerability",
    "Severity": "Critical",
    "Description": "The product allows the upload or transfer of dangerous file types that are automatically processed within its environment.",
    "Applicable Platforms": {
      "languages": [
        {
          "name": "ASP.NET",
          "prevalence": "Sometimes"
        },
        {
          "name": "PHP",
          "prevalence": "Often"
        },
        {
          "class": "Not Language-Specific",
          "prevalence": "Undetermined"
        }
      ],
      "technologies": [
        {
          "name": "Web Server",
          "prevalence": "Sometimes"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Architecture and Design",
        "description": "Generate a new, unique filename for an uploaded file instead of using the user-supplied filename, so that no external input is used at all.[REF-422] [REF-423]"
      },
      {
        "phase": "Architecture and Design",
        "strategy": "Enforcement by Conversion",
        "description": "When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs."
      },
      {
        "phase": "Architecture and Design",
        "description": "Consider storing the uploaded files outside of the web document root entirely. Then, use other mechanisms to deliver the files dynamically. [REF-423]"
      },
      {
        "phase": "Implementation",
        "strategy": "Input Validation",
        "description": "Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a list of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs. This is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, denylists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. For example, limiting filenames to alphanumeric characters can help to restrict the introduction of unintended file extensions."
      },
      {
        "phase": "Architecture and Design",
        "description": "Define a very limited set of allowable extensions and only generate filenames that end in these extensions. Consider the possibility of XSS (CWE-79) before allowing .html or .htm file types."
      },
      {
        "phase": "Implementation",
        "strategy": "Input Validation",
        "description": "Ensure that only one extension is used in the filename. Some web servers, including some versions of Apache, may process files based on inner extensions so that filename.php.gif is fed to the PHP interpreter.[REF-422] [REF-423]"
      },
      {
        "phase": "Implementation",
        "description": "When running on a web server that supports case-insensitive filenames, perform case-insensitive evaluations of the extensions that are provided."
      },
      {
        "phase": "Architecture and Design",
        "description": "For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server."
      },
      {
        "phase": "Implementation",
        "description": "Do not rely exclusively on sanity checks of file contents to ensure that the file is of the expected type and size. It may be possible for an attacker to hide code in some file segments that will still be executed by the server. For example, GIF images may contain a free-form comments field."
      },
      {
        "phase": "Implementation",
        "description": "Do not rely exclusively on the MIME content type or filename attribute when determining how to render a file. Validating the MIME content type and ensuring that it matches the extension is only a partial solution."
      },
      {
        "phase": "Architecture and Design Operation",
        "strategy": "Environment Hardening",
        "description": "Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations."
      },
      {
        "phase": "Architecture and Design Operation",
        "strategy": "Sandbox or Jail",
        "description": "Run the code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise. Be careful to avoid CWE-243 and other weaknesses related to jails.",
        "effectiveness": "Limited"
      }
    ]
  },
  {
    "CWE-ID": "CWE-456",
    "Name": "Missing Initialization of a Variable",
    "Category": "Initialization Error",
    "Severity": "Medium",
    "Description": "The product does not initialize critical variables, which causes the execution environment to use unexpected values.",
    "Applicable Platforms": {
      "languages": [
        {
          "class": "Not Language-Specific",
          "prevalence": "Undetermined"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Implementation",
        "strategy": "Attack Surface Reduction",
        "description": "Ensure that critical variables are initialized before first use [REF-1485]."
      },
      {
        "phase": "Requirements",
        "strategy": "Language Selection",
        "description": "Choose a language that is not susceptible to these issues."
      }
    ]
  },
  {
    "CWE-ID": "CWE-457",
    "Name": "Use of Uninitialized Variable",
    "Category": "Initialization Error",
    "Severity": "Medium",
    "Description": "The code uses a variable that has not been initialized, leading to unpredictable or unintended results.",
    "Applicable Platforms": {
      "languages": [
        {
          "name": "C",
          "prevalence": "Sometimes"
        },
        {
          "name": "C++",
          "prevalence": "Sometimes"
        },
        {
          "name": "Perl",
          "prevalence": "Often"
        },
        {
          "name": "PHP",
          "prevalence": "Often"
        },
        {
          "class": "Not Language-Specific",
          "prevalence": "Undetermined"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Implementation",
        "strategy": "Attack Surface Reduction",
        "description": "Ensure that critical variables are initialized before first use [REF-1485]."
      },
      {
        "phase": "Build and Compilation",
        "strategy": "Compilation or Build Hardening",
        "description": "Most compilers will complain about the use of uninitialized variables if warnings are turned on."
      },
      {
        "phase": "Implementation Operation",
        "description": "When using a language that does not require explicit declaration of variables, run or compile the software in a mode that reports undeclared or unknown variables. This may indicate the presence of a typographic error in the variable's name."
      },
      {
        "phase": "Requirements",
        "strategy": "Language Selection",
        "description": "Choose a language that is not susceptible to these issues."
      },
      {
        "phase": "Architecture and Design",
        "description": "Mitigating technologies such as safe string libraries and container abstractions could be introduced."
      }
    ]
  },
  {
    "CWE-ID": "CWE-477",
    "Name": "Use of Obsolete Function",
    "Category": "Obsolete Function",
    "Severity": "Low",
    "Description": "The code uses deprecated or obsolete functions, which suggests that the code has not been actively reviewed or maintained.",
    "Applicable Platforms": {
      "languages": [
        {
          "class": "Not Language-Specific",
          "prevalence": "Undetermined"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Implementation",
        "description": "Refer to the documentation for the obsolete function in order to determine why it is deprecated or obsolete and to learn about alternative ways to achieve the same functionality."
      },
      {
        "phase": "Requirements",
        "description": "Consider seriously the security implications of using an obsolete function. Consider using alternate functions."
      }
    ]
  },
  {
    "CWE-ID": "CWE-502",
    "Name": "Deserialization of Untrusted Data",
    "Category": "Deserialization Vulnerability",
    "Severity": "Critical",
    "Description": "The product deserializes untrusted data without sufficiently ensuring that the resulting data will be valid.",
    "Applicable Platforms": {
      "languages": [
        {
          "name": "Java",
          "prevalence": "Undetermined"
        },
        {
          "name": "Ruby",
          "prevalence": "Undetermined"
        },
        {
          "name": "PHP",
          "prevalence": "Undetermined"
        },
        {
          "name": "Python",
          "prevalence": "Undetermined"
        },
        {
          "name": "JavaScript",
          "prevalence": "Undetermined"
        }
      ],
      "technologies": [
        {
          "class": "ICS/OT",
          "prevalence": "Often"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Architecture and Design Implementation",
        "description": "If available, use the signing/sealing features of the programming language to assure that deserialized data has not been tainted. For example, a hash-based message authentication code (HMAC) could be used to ensure that data has not been modified."
      },
      {
        "phase": "Implementation",
        "description": "When deserializing data, populate a new object rather than just deserializing. The result is that the data flows through safe input validation and that the functions are safe."
      },
      {
        "phase": "Implementation",
        "description": "Explicitly define a final object() to prevent deserialization."
      },
      {
        "phase": "Architecture and Design Implementation",
        "description": "Make fields transient to protect them from deserialization. An attempt to serialize and then deserialize a class containing transient fields will result in NULLs where the transient data should be. This is an excellent way to prevent time, environment-based, or sensitive variables from being carried over and used improperly."
      },
      {
        "phase": "Implementation",
        "description": "Avoid having unnecessary types or gadgets (a sequence of instances and method invocations that can self-execute during the deserialization process, often found in libraries) available that can be leveraged for malicious ends. This limits the potential for unintended or unauthorized types and gadgets to be leveraged by the attacker. Add only acceptable classes to an allowlist. Note"
      },
      {
        "phase": "Architecture and Design Implementation",
        "description": "Employ cryptography of the data or code for protection. However, it's important to note that it would still be client-side security. This is risky because if the client is compromised then the security implemented on the client (the cryptography) can be bypassed."
      },
      {
        "phase": "Operation",
        "strategy": "Firewall",
        "description": "Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth [REF-1481].",
        "effectiveness": "Moderate"
      }
    ]
  },
  {
    "CWE-ID": "CWE-543",
    "Name": "Use of Singleton Pattern Without Synchronization in a Multithreaded Context",
    "Category": "Concurrency Issue",
    "Severity": "Medium",
    "Description": "The product uses the singleton pattern when creating a resource within a multithreaded environment.",
    "Applicable Platforms": {
      "languages": [
        {
          "name": "Java",
          "prevalence": "Undetermined"
        },
        {
          "name": "C++",
          "prevalence": "Undetermined"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Architecture and Design",
        "description": "Use the Thread-Specific Storage Pattern. See References."
      },
      {
        "phase": "Implementation",
        "description": "Do not use member fields to store information in the Servlet. In multithreading environments, storing user data in Servlet member fields introduces a data access race condition."
      },
      {
        "phase": "Implementation",
        "description": "Avoid using the double-checked locking pattern in language versions that cannot guarantee thread safety. This pattern may be used to avoid the overhead of a synchronized call, but in certain versions of Java (for example), this has been shown to be unsafe because it still introduces a race condition (CWE-209).",
        "effectiveness": "Limited"
      }
    ]
  },
  {
    "CWE-ID": "CWE-564",
    "Name": "SQL Injection: Hibernate",
    "Category": "SQL Injection",
    "Severity": "Critical",
    "Description": "Using Hibernate to execute a dynamic SQL statement built with user-controlled input can allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.",
    "Applicable Platforms": {
      "languages": [
        {
          "name": "SQL",
          "prevalence": "Often"
        }
      ],
      "technologies": [
        {
          "name": "Database Server",
          "prevalence": "Undetermined"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Requirements",
        "description": "A non-SQL style database which is not subject to this flaw may be chosen."
      },
      {
        "phase": "Architecture and Design",
        "description": "Follow the principle of least privilege when creating user accounts to a SQL database. Users should only have the minimum privileges necessary to use their account. If the requirements of the system indicate that a user can read and modify their own data, then limit their privileges so they cannot read/write others' data."
      },
      {
        "phase": "Architecture and Design",
        "description": "For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server."
      },
      {
        "phase": "Implementation",
        "description": "Implement SQL strings using prepared statements that bind variables. Prepared statements that do not bind variables can be vulnerable to attack."
      },
      {
        "phase": "Implementation",
        "description": "Use vigorous allowlist style checking on any user input that may be used in a SQL command. Rather than escape meta-characters, it is safest to disallow them entirely. Reason"
      }
    ]
  },
  {
    "CWE-ID": "CWE-567",
    "Name": "Unsynchronized Access to Shared Data in a Multithreaded Context",
    "Category": "Concurrency Issue",
    "Severity": "Medium",
    "Description": "The product does not properly synchronize shared data, such as static variables across threads, which can lead to undefined behavior and unpredictable data changes.",
    "Applicable Platforms": {
      "languages": [
        {
          "name": "Java",
          "prevalence": "Undetermined"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Implementation",
        "description": "Remove the use of static variables used between servlets. If this cannot be avoided, use synchronized access for these variables."
      }
    ]
  },
  {
    "CWE-ID": "CWE-570",
    "Name": "Expression is Always False",
    "Category": "Logic Error",
    "Severity": "Low",
    "Description": "The product contains an expression that will always evaluate to false.",
    "Applicable Platforms": {
      "languages": [
        {
          "class": "Not Language-Specific",
          "prevalence": "Undetermined"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Testing",
        "description": "Use Static Analysis tools to spot such conditions."
      }
    ]
  },
  {
    "CWE-ID": "CWE-571",
    "Name": "Expression is Always True",
    "Category": "Logic Error",
    "Severity": "Low",
    "Description": "The product contains an expression that will always evaluate to true.",
    "Applicable Platforms": {
      "languages": [
        {
          "class": "Not Language-Specific",
          "prevalence": "Undetermined"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Testing",
        "description": "Use Static Analysis tools to spot such conditions."
      }
    ]
  },
  {
    "CWE-ID": "CWE-606",
    "Name": "Unchecked Input for Loop Condition",
    "Category": "Logic Error",
    "Severity": "Medium",
    "Description": "The product does not properly check inputs that are used for loop conditions, potentially leading to a denial of service or other consequences because of excessive looping.",
    "Applicable Platforms": {},
    "Potential Mitigations": [
      {
        "phase": "Implementation",
        "description": "Do not use user-controlled data for loop conditions."
      },
      {
        "phase": "Implementation",
        "description": "Perform input validation."
      }
    ]
  },
  {
    "CWE-ID": "CWE-611",
    "Name": "Improper Restriction of XML External Entity Reference",
    "Category": "XML External Entity (XXE)",
    "Severity": "High",
    "Description": "The product processes an XML document that can contain XML entities with URIs that resolve to documents outside of the intended sphere of control, causing the product to embed incorrect documents into its output.",
    "Applicable Platforms": {
      "languages": [
        {
          "name": "XML",
          "prevalence": "Undetermined"
        }
      ],
      "technologies": [
        {
          "class": "Web Based",
          "prevalence": "Undetermined"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Implementation System Configuration",
        "description": "Many XML parsers and validators can be configured to disable external entity expansion."
      }
    ]
  },
  {
    "CWE-ID": "CWE-643",
    "Name": "Improper Neutralization of Data within XPath Expressions ('XPath Injection')",
    "Category": "XPath Injection",
    "Severity": "High",
    "Description": "The product uses external input to dynamically construct an XPath expression used to retrieve data from an XML database, but it does not neutralize or incorrectly neutralizes that input. This allows an attacker to control the structure of the query.",
    "Applicable Platforms": {
      "languages": [
        {
          "class": "Not Language-Specific",
          "prevalence": "Undetermined"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Implementation",
        "description": "Use parameterized XPath queries (e.g. using XQuery). This will help ensure separation between data plane and control plane."
      },
      {
        "phase": "Implementation",
        "description": "Properly validate user input. Reject data where appropriate, filter where appropriate and escape where appropriate. Make sure input that will be used in XPath queries is safe in that context."
      }
    ]
  },
  {
    "CWE-ID": "CWE-652",
    "Name": "Improper Neutralization of Data within XQuery Expressions ('XQuery Injection')",
    "Category": "XQuery Injection",
    "Severity": "High",
    "Description": "The product uses external input to dynamically construct an XQuery expression used to retrieve data from an XML database, but it does not neutralize or incorrectly neutralizes that input. This allows an attacker to control the structure of the query.",
    "Applicable Platforms": {
      "languages": [
        {
          "class": "Not Language-Specific",
          "prevalence": "Undetermined"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Implementation",
        "description": "Use parameterized queries. This will help ensure separation between data plane and control plane."
      },
      {
        "phase": "Implementation",
        "description": "Properly validate user input. Reject data where appropriate, filter where appropriate and escape where appropriate. Make sure input that will be used in XQL queries is safe in that context."
      }
    ]
  },
  {
    "CWE-ID": "CWE-662",
    "Name": "Improper Synchronization",
    "Category": "Concurrency Issue",
    "Severity": "Medium",
    "Description": "The product utilizes multiple threads or processes to allow temporary access to a shared resource that can only be exclusive to one process at a time, but it does not properly synchronize these actions, which might cause simultaneous accesses of this resource by multiple threads or processes.",
    "Applicable Platforms": {},
    "Potential Mitigations": [
      {
        "phase": "Implementation",
        "description": "Use industry standard APIs to synchronize your code."
      }
    ]
  },
  {
    "CWE-ID": "CWE-665",
    "Name": "Improper Initialization",
    "Category": "Initialization Error",
    "Severity": "Medium",
    "Description": "The product does not initialize or incorrectly initializes a resource, which might leave the resource in an unexpected state when it is accessed or used.",
    "Applicable Platforms": {
      "languages": [
        {
          "class": "Not Language-Specific",
          "prevalence": "Undetermined"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Requirements",
        "strategy": "Language Selection",
        "description": "Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, in Java, if the programmer does not explicitly initialize a variable, then the code could produce a compile-time error (if the variable is local) or automatically initialize the variable to the default value for the variable's type. In Perl, if explicit initialization is not performed, then a default value of undef is assigned, which is interpreted as 0, false, or an equivalent value depending on the context in which the variable is accessed."
      },
      {
        "phase": "Architecture and Design",
        "description": "Identify all variables and data stores that receive information from external sources, and apply input validation to make sure that they are only initialized to expected values."
      },
      {
        "phase": "Implementation",
        "description": "Explicitly initialize all your variables and other data stores, either during declaration or just before the first usage."
      },
      {
        "phase": "Implementation",
        "description": "Pay close attention to complex conditionals that affect initialization, since some conditions might not perform the initialization."
      },
      {
        "phase": "Implementation",
        "description": "Avoid race conditions (CWE-362) during initialization routines."
      },
      {
        "phase": "Build and Compilation",
        "description": "Run or compile your product with settings that generate warnings about uninitialized variables or data."
      },
      {
        "phase": "Testing",
        "description": "Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible."
      }
    ]
  },
  {
    "CWE-ID": "CWE-667",
    "Name": "Improper Locking",
    "Category": "Concurrency Issue",
    "Severity": "Medium",
    "Description": "The product does not properly acquire or release a lock on a resource, leading to unexpected resource state changes and behaviors.",
    "Applicable Platforms": {},
    "Potential Mitigations": [
      {
        "phase": "Implementation",
        "strategy": "Libraries or Frameworks",
        "description": "Use industry standard APIs to implement locking mechanism."
      }
    ]
  },
  {
    "CWE-ID": "CWE-672",
    "Name": "Operation on a Resource after Expiration or Release",
    "Category": "Resource Management Error",
    "Severity": "Medium",
    "Description": "The product uses, accesses, or otherwise operates on a resource after that resource has been expired, released, or revoked.",
    "Applicable Platforms": {
      "languages": [
        {
          "class": "Not Language-Specific",
          "prevalence": "Undetermined"
        }
      ],
      "technologies": [
        {
          "class": "Mobile",
          "prevalence": "Undetermined"
        }
      ]
    },
    "Potential Mitigations": []
  },
  {
    "CWE-ID": "CWE-681",
    "Name": "Incorrect Conversion between Numeric Types",
    "Category": "Numeric Error",
    "Severity": "Medium",
    "Description": "When converting from one data type to another, such as long to integer, data can be omitted or translated in a way that produces unexpected values. If the resulting values are used in a sensitive context, then dangerous behaviors may occur.",
    "Applicable Platforms": {
      "languages": [
        {
          "name": "C",
          "prevalence": "Undetermined"
        },
        {
          "class": "Not Language-Specific",
          "prevalence": "Undetermined"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Implementation",
        "description": "Avoid making conversion between numeric types. Always check for the allowed ranges."
      }
    ]
  },
  {
    "CWE-ID": "CWE-682",
    "Name": "Incorrect Calculation",
    "Category": "Numeric Error",
    "Severity": "Medium",
    "Description": "The product performs a calculation that generates incorrect or unintended results that are later used in security-critical decisions or resource management.",
    "Applicable Platforms": {
      "languages": [
        {
          "class": "Not Language-Specific",
          "prevalence": "Undetermined"
        }
      ],
      "technologies": [
        {
          "class": "Not Technology-Specific",
          "prevalence": "Undetermined"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Implementation",
        "description": "Understand your programming language's underlying representation and how it interacts with numeric calculation. Pay close attention to byte size discrepancies, precision, signed/unsigned distinctions, truncation, conversion and casting between types, not-a-number calculations, and how your language handles numbers that are too large or too small for its underlying representation."
      },
      {
        "phase": "Implementation",
        "strategy": "Input Validation",
        "description": "Perform input validation on any numeric input by ensuring that it is within the expected range. Enforce that the input meets both the minimum and maximum requirements for the expected range."
      },
      {
        "phase": "Implementation",
        "description": "Use the appropriate type for the desired action. For example, in C/C++, only use unsigned types for values that could never be negative, such as height, width, or other numbers related to quantity."
      },
      {
        "phase": "Architecture and Design",
        "strategy": "Language Selection",
        "description": "Use languages, libraries, or frameworks that make it easier to handle numbers without unexpected consequences. Examples include safe integer handling packages such as SafeInt (C++) or IntegerLib (C or C++)."
      },
      {
        "phase": "Architecture and Design",
        "strategy": "Libraries or Frameworks",
        "description": "Use languages, libraries, or frameworks that make it easier to handle numbers without unexpected consequences. Examples include safe integer handling packages such as SafeInt (C++) or IntegerLib (C or C++)."
      },
      {
        "phase": "Implementation",
        "strategy": "Compilation or Build Hardening",
        "description": "Examine compiler warnings closely and eliminate problems with potential security implications, such as signed / unsigned mismatch in memory operations, or use of uninitialized variables. Even if the weakness is rarely exploitable, a single failure may lead to the compromise of the entire system."
      },
      {
        "phase": "Testing",
        "description": "Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible."
      },
      {
        "phase": "Testing",
        "description": "Use dynamic tools and techniques that interact with the product using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The product's operation may slow down, but it should not become unstable, crash, or generate incorrect results."
      }
    ]
  },
  {
    "CWE-ID": "CWE-732",
    "Name": "Incorrect Permission Assignment for Critical Resource",
    "Category": "Permission Assignment Error",
    "Severity": "High",
    "Description": "The product specifies permissions for a security-critical resource in a way that allows that resource to be read or modified by unintended actors.",
    "Applicable Platforms": {
      "languages": [
        {
          "class": "Not Language-Specific",
          "prevalence": "Undetermined"
        }
      ],
      "technologies": [
        {
          "class": "Not Technology-Specific",
          "prevalence": "Undetermined"
        },
        {
          "class": "Cloud Computing",
          "prevalence": "Often"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Implementation",
        "description": "When using a critical resource such as a configuration file, check to see if the resource has insecure permissions (such as being modifiable by any regular user) [REF-62], and generate an error or even exit the software if there is a possibility that the resource could have been modified by an unauthorized party."
      },
      {
        "phase": "Architecture and Design",
        "description": "Divide the software into anonymous, normal, privileged, and administrative areas. Reduce the attack surface by carefully defining distinct user groups, privileges, and/or roles. Map these against data, functionality, and the related resources. Then set the permissions accordingly. This will allow you to maintain more fine-grained control over your resources. [REF-207]",
        "effectiveness": "Moderate"
      },
      {
        "phase": "Architecture and Design Operation",
        "strategy": "Sandbox or Jail",
        "description": "Run the code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise. Be careful to avoid CWE-243 and other weaknesses related to jails.",
        "effectiveness": "Limited"
      },
      {
        "phase": "Implementation Installation",
        "description": "During program startup, explicitly set the default permissions or umask to the most restrictive setting possible. Also set the appropriate permissions during program installation. This will prevent you from inheriting insecure permissions from any user who installs or runs the program.",
        "effectiveness": "High"
      },
      {
        "phase": "System Configuration",
        "description": "For all configuration files, executables, and libraries, make sure that they are only readable and writable by the software's administrator.",
        "effectiveness": "High"
      },
      {
        "phase": "Documentation",
        "description": "Do not suggest insecure configuration changes in documentation, especially if those configurations can extend to resources and other programs that are outside the scope of the application."
      },
      {
        "phase": "Installation",
        "description": "Do not assume that a system administrator will manually change the configuration to the settings that are recommended in the software's manual."
      },
      {
        "phase": "Operation System Configuration",
        "strategy": "Environment Hardening",
        "description": "Ensure that the software runs properly under the United States Government Configuration Baseline (USGCB) [REF-199] or an equivalent hardening configuration guide, which many organizations use to limit the attack surface and potential risk of deployed software."
      },
      {
        "phase": "Implementation System Configuration Operation",
        "description": "When storing data in the cloud (e.g., S3 buckets, Azure blobs, Google Cloud Storage, etc.), use the provider's controls to disable public access."
      }
    ]
  },
  {
    "CWE-ID": "CWE-772",
    "Name": "Missing Release of Resource after Effective Lifetime",
    "Category": "Resource Management Error",
    "Severity": "Medium",
    "Description": "The product does not release a resource after its effective lifetime has ended, i.e., after the resource is no longer needed.",
    "Applicable Platforms": {
      "technologies": [
        {
          "class": "Mobile",
          "prevalence": "Undetermined"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Requirements",
        "strategy": "Language Selection",
        "description": "Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, languages such as Java, Ruby, and Lisp perform automatic garbage collection that releases memory for objects that have been deallocated."
      },
      {
        "phase": "Implementation",
        "description": "It is good practice to be responsible for freeing all resources you allocate and to be consistent with how and where you free resources in a function. If you allocate resources that you intend to free upon completion of the function, you must be sure to free the resources at all exit points for that function including error conditions."
      },
      {
        "phase": "Operation Architecture and Design",
        "strategy": "Resource Limitation",
        "description": "Use resource-limiting settings provided by the operating system or environment. For example, when managing system resources in POSIX, setrlimit() can be used to set limits for certain types of resources, and getrlimit() can determine how many resources are available. However, these functions are not available on all operating systems. When the current levels get close to the maximum that is defined for the application (see CWE-770), then limit the allocation of further resources to privileged users; alternately, begin releasing resources for less-privileged users. While this mitigation may protect the system from attack, it will not necessarily stop attackers from adversely impacting other users. Ensure that the application performs the appropriate error checks and error handling in case resources become unavailable (CWE-703)."
      }
    ]
  },
  {
    "CWE-ID": "CWE-775",
    "Name": "Missing Release of File Descriptor or Handle after Effective Lifetime",
    "Category": "Resource Management Error",
    "Severity": "Medium",
    "Description": "The product does not release a file descriptor or handle after its effective lifetime has ended, i.e., after the file descriptor/handle is no longer needed.",
    "Applicable Platforms": {},
    "Potential Mitigations": [
      {
        "phase": "Operation Architecture and Design",
        "strategy": "Resource Limitation",
        "description": "Use resource-limiting settings provided by the operating system or environment. For example, when managing system resources in POSIX, setrlimit() can be used to set limits for certain types of resources, and getrlimit() can determine how many resources are available. However, these functions are not available on all operating systems. When the current levels get close to the maximum that is defined for the application (see CWE-770), then limit the allocation of further resources to privileged users; alternately, begin releasing resources for less-privileged users. While this mitigation may protect the system from attack, it will not necessarily stop attackers from adversely impacting other users. Ensure that the application performs the appropriate error checks and error handling in case resources become unavailable (CWE-703)."
      }
    ]
  },
  {
    "CWE-ID": "CWE-778",
    "Name": "Insufficient Logging",
    "Category": "Logging Issue",
    "Severity": "Medium",
    "Description": "When a security-critical event occurs, the product either does not record the event or omits important details about the event when logging it.",
    "Applicable Platforms": {
      "languages": [
        {
          "class": "Not Language-Specific",
          "prevalence": "Undetermined"
        }
      ],
      "technologies": [
        {
          "class": "Cloud Computing",
          "prevalence": "Undetermined"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Architecture and Design",
        "description": "Use a centralized logging mechanism that supports multiple levels of detail."
      },
      {
        "phase": "Implementation",
        "description": "Ensure that all security-related successes and failures can be logged. When storing data in the cloud (e.g., AWS S3 buckets, Azure blobs, Google Cloud Storage, etc.), use the provider's controls to enable and capture detailed logging information."
      },
      {
        "phase": "Operation",
        "description": "Be sure to set the level of logging appropriately in a production environment. Sufficient data should be logged to enable system administrators to detect attacks, diagnose errors, and recover from attacks. At the same time, logging too much data (CWE-779) can cause the same problems, including unexpected costs when using a cloud environment."
      },
      {
        "phase": "Operation",
        "description": "To enable storage logging using Azure's Portal, navigate to the name of the Storage Account, locate Monitoring (CLASSIC) section, and select Diagnostic settings (classic). For each of the various properties (blob, file, table, queue), ensure the status is properly set for the desired logging data. If using PowerShell, the Set-AzStorageServiceLoggingProperty command could be called using appropriate -ServiceType, -LoggingOperations, and -RetentionDays arguments."
      }
    ]
  },
  {
    "CWE-ID": "CWE-783",
    "Name": "Operator Precedence Logic Error",
    "Category": "Logic Error",
    "Severity": "Low",
    "Description": "The product uses an expression in which operator precedence causes incorrect logic to be used.",
    "Applicable Platforms": {
      "languages": [
        {
          "name": "C",
          "prevalence": "Rarely"
        },
        {
          "name": "C++",
          "prevalence": "Rarely"
        },
        {
          "class": "Not Language-Specific",
          "prevalence": "Rarely"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Implementation",
        "description": "Regularly wrap sub-expressions in parentheses, especially in security-critical code."
      }
    ]
  },
  {
    "CWE-ID": "CWE-786",
    "Name": "Access of Memory Location Before Start of Buffer",
    "Category": "Memory Buffer Error",
    "Severity": "High",
    "Description": "The product reads or writes to a buffer using an index or pointer that references a memory location prior to the beginning of the buffer.",
    "Applicable Platforms": {
      "languages": [
        {
          "name": "C",
          "prevalence": "Often"
        },
        {
          "name": "C++",
          "prevalence": "Often"
        }
      ]
    },
    "Potential Mitigations": []
  },
  {
    "CWE-ID": "CWE-787",
    "Name": "Out-of-bounds Write",
    "Category": "Memory Buffer Error",
    "Severity": "Critical",
    "Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
    "Applicable Platforms": {
      "languages": [
        {
          "name": "C",
          "prevalence": "Often"
        },
        {
          "name": "C++",
          "prevalence": "Often"
        },
        {
          "class": "Assembly",
          "prevalence": "Undetermined"
        }
      ],
      "technologies": [
        {
          "class": "ICS/OT",
          "prevalence": "Often"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Requirements",
        "strategy": "Language Selection",
        "description": "Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer. Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe."
      },
      {
        "phase": "Architecture and Design",
        "strategy": "Libraries or Frameworks",
        "description": "Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions."
      },
      {
        "phase": "Operation Build and Compilation",
        "strategy": "Environment Hardening",
        "description": "Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include"
      },
      {
        "phase": "Implementation",
        "description": "Consider adhering to the following rules when allocating and managing an application's memory"
      },
      {
        "phase": "Operation Build and Compilation",
        "strategy": "Environment Hardening",
        "description": "Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as rebasing (for Windows) and prelinking (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking. For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].",
        "effectiveness": "Defense in Depth"
      },
      {
        "phase": "Operation",
        "strategy": "Environment Hardening",
        "description": "Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment. For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].",
        "effectiveness": "Defense in Depth"
      },
      {
        "phase": "Implementation",
        "description": "Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.",
        "effectiveness": "Moderate"
      }
    ]
  },
  {
    "CWE-ID": "CWE-788",
    "Name": "Access of Memory Location After End of Buffer",
    "Category": "Memory Buffer Error",
    "Severity": "High",
    "Description": "The product reads or writes to a buffer using an index or pointer that references a memory location after the end of the buffer.",
    "Applicable Platforms": {
      "languages": [
        {
          "name": "C",
          "prevalence": "Often"
        },
        {
          "name": "C++",
          "prevalence": "Often"
        }
      ]
    },
    "Potential Mitigations": []
  },
  {
    "CWE-ID": "CWE-789",
    "Name": "Memory Allocation with Excessive Size Value",
    "Category": "Memory Management Error",
    "Severity": "Medium",
    "Description": "The product allocates memory based on an untrusted, large size value, but it does not ensure that the size is within expected limits, allowing arbitrary amounts of memory to be allocated.",
    "Applicable Platforms": {
      "languages": [
        {
          "name": "C",
          "prevalence": "Undetermined"
        },
        {
          "name": "C++",
          "prevalence": "Undetermined"
        },
        {
          "class": "Not Language-Specific",
          "prevalence": "Undetermined"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Implementation Architecture and Design",
        "description": "Perform adequate input validation against any value that influences the amount of memory that is allocated. Define an appropriate strategy for handling requests that exceed the limit, and consider supporting a configuration option so that the administrator can extend the amount of memory to be used if necessary."
      },
      {
        "phase": "Operation",
        "description": "Run your program using system-provided resource limits for memory. This might still cause the program to crash or exit, but the impact to the rest of the system will be minimized."
      }
    ]
  },
  {
    "CWE-ID": "CWE-798",
    "Name": "Use of Hard-coded Credentials",
    "Category": "Hard-coded Credentials",
    "Severity": "High",
    "Description": "The product contains hard-coded credentials, such as a password or cryptographic key.",
    "Applicable Platforms": {
      "languages": [
        {
          "class": "Not Language-Specific",
          "prevalence": "Undetermined"
        }
      ],
      "technologies": [
        {
          "class": "Mobile",
          "prevalence": "Undetermined"
        },
        {
          "class": "ICS/OT",
          "prevalence": "Often"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Architecture and Design",
        "description": "For outbound authentication"
      },
      {
        "phase": "Architecture and Design",
        "description": "For inbound authentication"
      },
      {
        "phase": "Architecture and Design",
        "description": "If the product must contain hard-coded credentials or they cannot be removed, perform access control checks and limit which entities can access the feature that requires the hard-coded credentials. For example, a feature might only be enabled through the system console instead of through a network connection."
      },
      {
        "phase": "Architecture and Design",
        "description": "For inbound authentication using passwords"
      },
      {
        "phase": "Architecture and Design",
        "description": "For front-end to back-end connections"
      }
    ]
  },
  {
    "CWE-ID": "CWE-805",
    "Name": "Buffer Access with Incorrect Length Value",
    "Category": "Memory Buffer Error",
    "Severity": "High",
    "Description": "The product uses a sequential operation to read or write a buffer, but it uses an incorrect length value that causes it to access memory that is outside of the bounds of the buffer.",
    "Applicable Platforms": {
      "languages": [
        {
          "name": "C",
          "prevalence": "Often"
        },
        {
          "name": "C++",
          "prevalence": "Often"
        },
        {
          "class": "Assembly",
          "prevalence": "Undetermined"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Requirements",
        "strategy": "Language Selection",
        "description": "Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer. Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe."
      },
      {
        "phase": "Architecture and Design",
        "strategy": "Libraries or Frameworks",
        "description": "Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions."
      },
      {
        "phase": "Operation Build and Compilation",
        "strategy": "Environment Hardening",
        "description": "Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include"
      },
      {
        "phase": "Implementation",
        "description": "Consider adhering to the following rules when allocating and managing an application's memory"
      },
      {
        "phase": "Architecture and Design",
        "description": "For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server."
      },
      {
        "phase": "Operation Build and Compilation",
        "strategy": "Environment Hardening",
        "description": "Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as rebasing (for Windows) and prelinking (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking. For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335].",
        "effectiveness": "Defense in Depth"
      },
      {
        "phase": "Operation",
        "strategy": "Environment Hardening",
        "description": "Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment. For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336].",
        "effectiveness": "Defense in Depth"
      },
      {
        "phase": "Architecture and Design Operation",
        "strategy": "Environment Hardening",
        "description": "Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the product or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations."
      },
      {
        "phase": "Architecture and Design Operation",
        "strategy": "Sandbox or Jail",
        "description": "Run the code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise. Be careful to avoid CWE-243 and other weaknesses related to jails.",
        "effectiveness": "Limited"
      }
    ]
  },
  {
    "CWE-ID": "CWE-820",
    "Name": "Missing Synchronization",
    "Category": "Concurrency Issue",
    "Severity": "Medium",
    "Description": "The product utilizes a shared resource in a concurrent manner but does not attempt to synchronize access to the resource.",
    "Applicable Platforms": {},
    "Potential Mitigations": []
  },
  {
    "CWE-ID": "CWE-821",
    "Name": "Incorrect Synchronization",
    "Category": "Concurrency Issue",
    "Severity": "Medium",
    "Description": "The product utilizes a shared resource in a concurrent manner, but it does not correctly synchronize access to the resource.",
    "Applicable Platforms": {},
    "Potential Mitigations": []
  },
  {
    "CWE-ID": "CWE-822",
    "Name": "Untrusted Pointer Dereference",
    "Category": "Pointer Issue",
    "Severity": "High",
    "Description": "The product obtains a value from an untrusted source, converts this value to a pointer, and dereferences the resulting pointer.",
    "Applicable Platforms": {},
    "Potential Mitigations": []
  },
  {
    "CWE-ID": "CWE-823",
    "Name": "Use of Out-of-range Pointer Offset",
    "Category": "Pointer Issue",
    "Severity": "High",
    "Description": "The product performs pointer arithmetic on a valid pointer, but it uses an offset that can point outside of the intended range of valid memory locations for the resulting pointer.",
    "Applicable Platforms": {},
    "Potential Mitigations": []
  },
  {
    "CWE-ID": "CWE-824",
    "Name": "Access of Uninitialized Pointer",
    "Category": "Pointer Issue",
    "Severity": "High",
    "Description": "The product accesses or uses a pointer that has not been initialized.",
    "Applicable Platforms": {
      "languages": [
        {
          "name": "C",
          "prevalence": "Undetermined"
        },
        {
          "name": "C++",
          "prevalence": "Undetermined"
        }
      ]
    },
    "Potential Mitigations": []
  },
  {
    "CWE-ID": "CWE-825",
    "Name": "Expired Pointer Dereference",
    "Category": "Pointer Issue",
    "Severity": "High",
    "Description": "The product dereferences a pointer that contains a location for memory that was previously valid, but is no longer valid.",
    "Applicable Platforms": {
      "languages": [
        {
          "name": "C",
          "prevalence": "Undetermined"
        },
        {
          "name": "C++",
          "prevalence": "Undetermined"
        }
      ]
    },
    "Potential Mitigations": [
      {
        "phase": "Architecture and Design",
        "description": "Choose a language that provides automatic memory management."
      },
      {
        "phase": "Implementation",
        "description": "When freeing pointers, be sure to set them to NULL once they are freed. However, the utilization of multiple or complex data structures may lower the usefulness of this strategy."
      }
    ]
  },
  {
    "CWE-ID": "CWE-835",
    "Name": "Loop with Unreachable Exit Condition ('Infinite Loop')",
    "Category": "Infinite Loop",
    "Severity": "Medium",
    "Description": "The product contains an iteration or loop with an exit condition that cannot be reached, i.e., an infinite loop.",
    "Applicable Platforms": {
      "languages": [
        {
          "class": "Not Language-Specific",
          "prevalence": "Undetermined"
        }
      ]
    },
    "Potential Mitigations": []
  },
  {
    "CWE-ID": "CWE-1057",
    "Name": "Data Access Operations Outside of Expected Data Manager Component",
    "Category": "Architectural Issue",
    "Severity": "Medium",
    "Description": "The product uses a dedicated, central data manager component as required by design, but it contains code that performs data-access operations that do not use this data manager.",
    "Applicable Platforms": {},
    "Potential Mitigations": []
  }
]